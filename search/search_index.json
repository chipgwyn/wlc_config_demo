{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Intern Immersion Day 2024 - Ansible Automation Demo","title":"Home"},{"location":"#intern-immersion-day-2024-ansible-automation-demo","text":"","title":"Intern Immersion Day 2024 - Ansible Automation Demo"},{"location":"ansible_use/","text":"Ansible For the lab we're going to be using Ansible to perform most of our work. Ansible is a framework to do \"things\" on remote hosts. There are many ways to connect to those hosts and also many \"actions\" that can be performed on those hosts. These actions can be configured into \"tasks\" that can then be composed into a \"play\". Further, plays can be made of reusable \"roles\" to achieve the desired state of a device. We'll now configure ansible to connect to our WLC and push the configuration of our wireless lan. A Note on Editors When working in the shell of a linux host there are usually at least two tools availble to edit files; vi and nano. Which one you choose to use is of personal preference and deciding which one you should use is the source of many debates. For the purpose of this tutorial we'll be using nano. If you are familiar with vi and would prefer to use it, feel free to. Both are excellent tools. Using vi Using nano Ansible Demos Ansible Inventory Ansible Config Pus","title":"Ansible Demo"},{"location":"ansible_use/#ansible","text":"For the lab we're going to be using Ansible to perform most of our work. Ansible is a framework to do \"things\" on remote hosts. There are many ways to connect to those hosts and also many \"actions\" that can be performed on those hosts. These actions can be configured into \"tasks\" that can then be composed into a \"play\". Further, plays can be made of reusable \"roles\" to achieve the desired state of a device. We'll now configure ansible to connect to our WLC and push the configuration of our wireless lan.","title":"Ansible"},{"location":"ansible_use/#a-note-on-editors","text":"When working in the shell of a linux host there are usually at least two tools availble to edit files; vi and nano. Which one you choose to use is of personal preference and deciding which one you should use is the source of many debates. For the purpose of this tutorial we'll be using nano. If you are familiar with vi and would prefer to use it, feel free to. Both are excellent tools. Using vi Using nano","title":"A Note on Editors"},{"location":"ansible_use/#ansible-demos","text":"Ansible Inventory Ansible Config Pus","title":"Ansible Demos"},{"location":"environment_setup/","text":"Environment Setup Connect to the lab host We're going to ssh to the host with your provided username ssh <username>@<hostname> If this is the first time connecting to the remote host you will be prompted to save the host's public ssh key. Answer y to the question The authenticity of host 'host.example.com (127.10.20.2)' can't be established. ED25519 key fingerprint is SHA256:hcg+1iEUsdfsdfsdfB5OBrl42NwRSDFsdfSFSmGa28bZ6IqRc. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])? Clone the lab git repository This lab's setup is contained in a git repository located at https://github.com/chipgwyn/wlc_config_demo. Git provides a way to manage changes to a set of files. This is called a Version Control System (VCS). It allows the ability to reference any changed version of a file or set of files while also allowing for collaboration between multiple people and then managing the integration of those changes. As features are added and bugs are fixed we can refer to a single place to see all the work that's going into a project. To 'clone' the lab repo run the following command: git clone https://github.com/chipgwyn/wlc_config_demo.git The command just copied all the files from the repo from the 'main' branch down to the host and placed it in your current directory. Have a look at what was all copied: tree wlc_config_demo The output should look something like the following: wlc_config_demo/ \u251c\u2500\u2500 ansible.cfg \u251c\u2500\u2500 inventory.yml \u251c\u2500\u2500 playbooks \u2502 \u2514\u2500\u2500 configure.yml \u251c\u2500\u2500 requirements.txt \u2514\u2500\u2500 roles \u2514\u2500\u2500 wlc_config \u251c\u2500\u2500 tasks \u2502 \u2514\u2500\u2500 main.yml \u251c\u2500\u2500 templates \u2502 \u251c\u2500\u2500 add_definition_wlan_config.j2 \u2502 \u251c\u2500\u2500 remove_definition_wlan_config.j2 \u2502 \u2514\u2500\u2500 wlc_config.j2 \u2514\u2500\u2500 vars \u2514\u2500\u2500 main.yml 6 directories, 9 files Setup a python virtual environment The host has python installed on it, however it does not have all the libraries and tools we need to perform our work. Generally we do not want to install all those things into the \"system's\" python environment, we want to install them only for the job we're doing. Installing a python library is normally done via a tool called pip . The pip tool will reach to and then download and install the package. Each package installed is maintained independently (usually) of any other packages available. PyPi is just the defacto repository for hosting packages. As bugs are fixed and features are added to packages their versions will change. What happens when the tool you are using requires one version of a particular package but another tool (or user) needs a different version? You have problems! The accepted way to work around this issue is to use a Python Virtual Environment . The idea is to use the same overall Python version your system uses but have a separate installation of specific packages to meet your needs. To create our virtual environment run the following commands: cd python3 -m venv ./venv There should now be a directory called 'venv' in your home dir: ls will show the files We have now created the python virtual environment however we must activate it in order to tell the system we want to use it over the global system's python. To see where your environment is looking for python run which python3 . This should show /usr/bin/python3 . Now Run the command source ./venv/bin/activate . You should notice that the prompt in your shell changed to indicate the virtual environment is activated. It will be prefixed with (venv) . Run which python3 again and notice that it will now point to something like /home/<username>/venv/bin/python3 At any time we can run deactivate to switch back to the global system's python. Install Ansible Now that we have our virtualenv we can install ansible and related tools and packages. NOTE Before proceeding be sure your python virtual environment is activated! As noted before we can install python packages using the pip tool. Pip will install the package specified and can take an argument for the specific version as well. The really nice thing is that any requested package installation will have all of its package dependencies installed along side it, and then any of those package's dependencies! This makes installing a package pretty easy (usually). Lets install the ansible-core package by running pip install ansible-core . This will get the very bare bits of ansible installed along with the minimum required dependencies. For our lab we want not only ansible-core but several of the additional tools as well. The de-facto standard for what all packages to install for a given project is to have them listed in a requirements.txt file. This file lists the specific package names and versions needed for a given environment. Move into the wlc_config_demo directory and have a look at the requirements.txt file cd wlc_config_demo cat requirements.txt Now we can install each of those packages one at a time or we can just tell pip to do everything listed in the file Run the command: pip install -r requirements.txt You should be seeing a lot of output showing what all is being installed. Once completed we should be ready to start using ansible. One more thing before we start. Suppose you want to confirm exactly what all packages and versions are installed in your environment. Run the command: pip freeze You should see a list of packages and version installed. It looks very similar to what was in the requirements.txt file. Frequently this is what's used to generate the requirements.txt file. When you're working on a project and you want to save the current list of packages and versions you can just save this output in your requirements.txt and be sure that the environment is the same the next time you want to use it (or need to start over). You should now be good to continue with lab","title":"Environment Setup"},{"location":"environment_setup/#environment-setup","text":"","title":"Environment Setup"},{"location":"environment_setup/#connect-to-the-lab-host","text":"We're going to ssh to the host with your provided username ssh <username>@<hostname> If this is the first time connecting to the remote host you will be prompted to save the host's public ssh key. Answer y to the question The authenticity of host 'host.example.com (127.10.20.2)' can't be established. ED25519 key fingerprint is SHA256:hcg+1iEUsdfsdfsdfB5OBrl42NwRSDFsdfSFSmGa28bZ6IqRc. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])?","title":"Connect to the lab host"},{"location":"environment_setup/#clone-the-lab-git-repository","text":"This lab's setup is contained in a git repository located at https://github.com/chipgwyn/wlc_config_demo. Git provides a way to manage changes to a set of files. This is called a Version Control System (VCS). It allows the ability to reference any changed version of a file or set of files while also allowing for collaboration between multiple people and then managing the integration of those changes. As features are added and bugs are fixed we can refer to a single place to see all the work that's going into a project. To 'clone' the lab repo run the following command: git clone https://github.com/chipgwyn/wlc_config_demo.git The command just copied all the files from the repo from the 'main' branch down to the host and placed it in your current directory. Have a look at what was all copied: tree wlc_config_demo The output should look something like the following: wlc_config_demo/ \u251c\u2500\u2500 ansible.cfg \u251c\u2500\u2500 inventory.yml \u251c\u2500\u2500 playbooks \u2502 \u2514\u2500\u2500 configure.yml \u251c\u2500\u2500 requirements.txt \u2514\u2500\u2500 roles \u2514\u2500\u2500 wlc_config \u251c\u2500\u2500 tasks \u2502 \u2514\u2500\u2500 main.yml \u251c\u2500\u2500 templates \u2502 \u251c\u2500\u2500 add_definition_wlan_config.j2 \u2502 \u251c\u2500\u2500 remove_definition_wlan_config.j2 \u2502 \u2514\u2500\u2500 wlc_config.j2 \u2514\u2500\u2500 vars \u2514\u2500\u2500 main.yml 6 directories, 9 files","title":"Clone the lab git repository"},{"location":"environment_setup/#setup-a-python-virtual-environment","text":"The host has python installed on it, however it does not have all the libraries and tools we need to perform our work. Generally we do not want to install all those things into the \"system's\" python environment, we want to install them only for the job we're doing. Installing a python library is normally done via a tool called pip . The pip tool will reach to and then download and install the package. Each package installed is maintained independently (usually) of any other packages available. PyPi is just the defacto repository for hosting packages. As bugs are fixed and features are added to packages their versions will change. What happens when the tool you are using requires one version of a particular package but another tool (or user) needs a different version? You have problems! The accepted way to work around this issue is to use a Python Virtual Environment . The idea is to use the same overall Python version your system uses but have a separate installation of specific packages to meet your needs. To create our virtual environment run the following commands: cd python3 -m venv ./venv There should now be a directory called 'venv' in your home dir: ls will show the files We have now created the python virtual environment however we must activate it in order to tell the system we want to use it over the global system's python. To see where your environment is looking for python run which python3 . This should show /usr/bin/python3 . Now Run the command source ./venv/bin/activate . You should notice that the prompt in your shell changed to indicate the virtual environment is activated. It will be prefixed with (venv) . Run which python3 again and notice that it will now point to something like /home/<username>/venv/bin/python3 At any time we can run deactivate to switch back to the global system's python.","title":"Setup a python virtual environment"},{"location":"environment_setup/#install-ansible","text":"Now that we have our virtualenv we can install ansible and related tools and packages. NOTE Before proceeding be sure your python virtual environment is activated! As noted before we can install python packages using the pip tool. Pip will install the package specified and can take an argument for the specific version as well. The really nice thing is that any requested package installation will have all of its package dependencies installed along side it, and then any of those package's dependencies! This makes installing a package pretty easy (usually). Lets install the ansible-core package by running pip install ansible-core . This will get the very bare bits of ansible installed along with the minimum required dependencies. For our lab we want not only ansible-core but several of the additional tools as well. The de-facto standard for what all packages to install for a given project is to have them listed in a requirements.txt file. This file lists the specific package names and versions needed for a given environment. Move into the wlc_config_demo directory and have a look at the requirements.txt file cd wlc_config_demo cat requirements.txt Now we can install each of those packages one at a time or we can just tell pip to do everything listed in the file Run the command: pip install -r requirements.txt You should be seeing a lot of output showing what all is being installed. Once completed we should be ready to start using ansible. One more thing before we start. Suppose you want to confirm exactly what all packages and versions are installed in your environment. Run the command: pip freeze You should see a list of packages and version installed. It looks very similar to what was in the requirements.txt file. Frequently this is what's used to generate the requirements.txt file. When you're working on a project and you want to save the current list of packages and versions you can just save this output in your requirements.txt and be sure that the environment is the same the next time you want to use it (or need to start over). You should now be good to continue with lab","title":"Install Ansible"},{"location":"intro_automation/","text":"Automation We've already touched on this a bit with the use of templates; things are consistent, repeatable, and expected. This greatly aids the administrators in their day-to-day work, cuts down on errors and misconfigurations, and speeds troubleshooting. The templating is only part of our goal. We've got the config that we're going to apply standardized! This is great! Now we need to get that config onto the device. The user will take the generated config and copy and paste the config onto the device. This has problems as well. Sometimes the user might not copy all the config, leaving out a line or perhaps a character at the end of the line. I'll just write a script to do it! We can write a program to take in a file of wireless lan definitions, combine them with our templates, and then push them to the WLC over ssh ( ssh is the native connection method for managing the WLC config ). We soon find that writing on our own code to interact with the WLC is fraught with peril. There are multiple ways to authenticate and then gain admin privileges. We have to write code to identify which method is being used and then react accordingly. This is not insurmountable but isn't strictly in the scope of what we're trying to accomplish. We forge ahead however and get that solved. At this point we've connected to our device and authenticated. We now need to enable the config mode of the device at which point it may tell us we're not authorized, someone else is already in config mode, or many other various possibilities. Again, not impossible to figure out since we can code to the most likely scenarios and just raise errors and abort for unexpected or infrequent use cases. Now we must send our rendered config template to the device. This is not just copying a file but emulating typing the file out line by line to the WLC. Depending on the device and its current status it may not work well if we send each line too fast. The \"config engine\" on the device has to interpret the config as it receives each word/line. If we send things too fast it may not be able to keep up and skip some of the config we've sent. This leaves us in a bad spot of incomplete or errored config, so we may get unexpected results. Ok, we can slow down the sending of each word/line to make sure the device gets all our config. So how exactly do we \"make sure\" our config was deployed correctly? Now we should pull the current config of the device after we insert and make sure that our lines (in the order specified) exist in the config. Generally this works pretty well but we find some situations where the device has changed the order of the lines from our template or perhaps the spacing of the config is changed slightly from our template. We have to go back to our template and make these changes there to match. This works most of the time but we find a situations where even if we slow down the insertion of the config to 5 seconds per line we still get errors. After some troubleshooting we find that these instances happen when the CPU usage of the WLC is at 80% or higher. The high CPU indicates the controller is busy doing other tasks or something has gone wrong. Now we must check the CPU before we begin the configuration. So we code that. ... The point of explaining all this is to illustrate that tasks we believe to be simple and straightforward can become cumbersome and complex in practice. Additionally, the code we've just written is very specific to this use case. Assume we wanted to deploy some configuration to a network switch, a linux host, or a windows host. We now have more edge cases to take into consideration. If we're lucky to have good programmers and who also have a deep understanding of the platforms we can modularize the code for re-use and composition. Automation Frameworks Lucky for us we can stand on the shoulders of giants and those who have come before us and leverage tools built for this specific problem domain. Ansible Salt Terraform Nornir Cisco Catalyst Center Some of these are vendor specific, open source, closed source, cater to networking, or cloud environments and services; there are lots to choose from based on the specific needs of your situation. Tooling can be used in concert with each other to cover many use cases and platforms. For our demo today we will focus on using Ansible and further focus on network automation. Idempotency Before we get into some details we should cover the idea of idempotency. Idempotence, is the property of certain operations in mathematics and computer science whereby they can be applied multiple times without changing the result beyond the initial application. Wikipedia For our use this describes the idea that if we make a change to a system, by some function, that repeating that function makes no additional change to the system other than the change that was initially made. For example if we wanted to add a wireless lan config to our WLC we can run a function that does that. If we run that function again we're not going to add \"additional\" config to the system. The function should recognize that the config we want to exist is already there and thus not perform a change. The idea here is that we feel comfortable running an ansible playbook multiple times and it will make no changes once the desired state of the device is achieved. Declarative vs Imperative Functions Most of the automation platforms and frameworks use a \"declarative\" style of interaction. This means that we describe the intended state of the system and not necessarily the exact steps to get there. Obviously those have to bd defined somewhere, that part is usually covered by the functions provided by the automation platform itself. We don't (usually) have to define those bits. We tell the platform what we want the system to look like and the platform will decide what steps are needed to achieve that state based on the situation. The exact actions that take place to achieve the desired state are written in the \"imperative\" manner. The difference here is subtle but should be understood. Imperative is a stringent set of individual steps that achieve the desired state. Whereas declarative defines the ultimate state of the system and composes the steps required to achieve the final state based on the current state.","title":"Automation Intro"},{"location":"intro_automation/#automation","text":"We've already touched on this a bit with the use of templates; things are consistent, repeatable, and expected. This greatly aids the administrators in their day-to-day work, cuts down on errors and misconfigurations, and speeds troubleshooting. The templating is only part of our goal. We've got the config that we're going to apply standardized! This is great! Now we need to get that config onto the device. The user will take the generated config and copy and paste the config onto the device. This has problems as well. Sometimes the user might not copy all the config, leaving out a line or perhaps a character at the end of the line.","title":"Automation"},{"location":"intro_automation/#ill-just-write-a-script-to-do-it","text":"We can write a program to take in a file of wireless lan definitions, combine them with our templates, and then push them to the WLC over ssh ( ssh is the native connection method for managing the WLC config ). We soon find that writing on our own code to interact with the WLC is fraught with peril. There are multiple ways to authenticate and then gain admin privileges. We have to write code to identify which method is being used and then react accordingly. This is not insurmountable but isn't strictly in the scope of what we're trying to accomplish. We forge ahead however and get that solved. At this point we've connected to our device and authenticated. We now need to enable the config mode of the device at which point it may tell us we're not authorized, someone else is already in config mode, or many other various possibilities. Again, not impossible to figure out since we can code to the most likely scenarios and just raise errors and abort for unexpected or infrequent use cases. Now we must send our rendered config template to the device. This is not just copying a file but emulating typing the file out line by line to the WLC. Depending on the device and its current status it may not work well if we send each line too fast. The \"config engine\" on the device has to interpret the config as it receives each word/line. If we send things too fast it may not be able to keep up and skip some of the config we've sent. This leaves us in a bad spot of incomplete or errored config, so we may get unexpected results. Ok, we can slow down the sending of each word/line to make sure the device gets all our config. So how exactly do we \"make sure\" our config was deployed correctly? Now we should pull the current config of the device after we insert and make sure that our lines (in the order specified) exist in the config. Generally this works pretty well but we find some situations where the device has changed the order of the lines from our template or perhaps the spacing of the config is changed slightly from our template. We have to go back to our template and make these changes there to match. This works most of the time but we find a situations where even if we slow down the insertion of the config to 5 seconds per line we still get errors. After some troubleshooting we find that these instances happen when the CPU usage of the WLC is at 80% or higher. The high CPU indicates the controller is busy doing other tasks or something has gone wrong. Now we must check the CPU before we begin the configuration. So we code that. ... The point of explaining all this is to illustrate that tasks we believe to be simple and straightforward can become cumbersome and complex in practice. Additionally, the code we've just written is very specific to this use case. Assume we wanted to deploy some configuration to a network switch, a linux host, or a windows host. We now have more edge cases to take into consideration. If we're lucky to have good programmers and who also have a deep understanding of the platforms we can modularize the code for re-use and composition.","title":"I'll just write a script to do it!"},{"location":"intro_automation/#automation-frameworks","text":"Lucky for us we can stand on the shoulders of giants and those who have come before us and leverage tools built for this specific problem domain. Ansible Salt Terraform Nornir Cisco Catalyst Center Some of these are vendor specific, open source, closed source, cater to networking, or cloud environments and services; there are lots to choose from based on the specific needs of your situation. Tooling can be used in concert with each other to cover many use cases and platforms. For our demo today we will focus on using Ansible and further focus on network automation.","title":"Automation Frameworks"},{"location":"intro_automation/#idempotency","text":"Before we get into some details we should cover the idea of idempotency. Idempotence, is the property of certain operations in mathematics and computer science whereby they can be applied multiple times without changing the result beyond the initial application. Wikipedia For our use this describes the idea that if we make a change to a system, by some function, that repeating that function makes no additional change to the system other than the change that was initially made. For example if we wanted to add a wireless lan config to our WLC we can run a function that does that. If we run that function again we're not going to add \"additional\" config to the system. The function should recognize that the config we want to exist is already there and thus not perform a change. The idea here is that we feel comfortable running an ansible playbook multiple times and it will make no changes once the desired state of the device is achieved.","title":"Idempotency"},{"location":"intro_automation/#declarative-vs-imperative-functions","text":"Most of the automation platforms and frameworks use a \"declarative\" style of interaction. This means that we describe the intended state of the system and not necessarily the exact steps to get there. Obviously those have to bd defined somewhere, that part is usually covered by the functions provided by the automation platform itself. We don't (usually) have to define those bits. We tell the platform what we want the system to look like and the platform will decide what steps are needed to achieve that state based on the situation. The exact actions that take place to achieve the desired state are written in the \"imperative\" manner. The difference here is subtle but should be understood. Imperative is a stringent set of individual steps that achieve the desired state. Whereas declarative defines the ultimate state of the system and composes the steps required to achieve the final state based on the current state.","title":"Declarative vs Imperative Functions"},{"location":"intro_templating/","text":"The config wlan {{ wlan_name|upper }} {{ wlan_id }} {{ wlan_ssid|title }} security wpa psk set-key ascii 0 {{ wlan_password }} no security wpa akm dot1x security wpa akm psk no shutdown wireless tag policy {{ wlan_name|upper }}-policy-tag description \"Policy Tag for {{ wlan_name|upper }}-policy-tag\" wlan {{ wlan_name|upper }} policy COMPANY-POL-PROF Templates What you see above is the configuration snippet that will define a wifi network and then attach that definition to a particular wireless policy. You'll notice there are several words surrounded by {{ }}. These are variables that can be defined elsewhere. Effectively what the above is showing is a template for the config. We can fill in those variables with names and IDs that meet our needs. The rest of the config is pretty much the same. We can repeat this 100 times, defining 100 lans, and know that they are all configured correctly; no lines missing, ensure a description is added, configured to meet our exact specifications and needs. Some things to note here. - We want the \"wlan_name\" to always be uppercase, aids in spotting the specific config when looking at 100s of lines - We want the \"wlan_ssid\" to use TitleCase, purely aesthetic choice - The wlan ID should always be an integer. If the data provided is not an integer and error will be raised You'll notice that after some of the variable names inside the template have int or title or upper . These are further definitions that will convert whatever is provided to an integer (int), make the name all upper case (upper), or make the string use Title Case (title). So now not only is our config consistent but the format of our provided variables are consistent as well. When perusing the config it makes non-standard config stand out easier. If needed we can build templates for multiple use cases. In the above example the authentication is just using a pre-shared-key, a password shared with everyone that wants to connect to wifi. Perhaps we wanted another template that defined a wifi network that was more secure where every user had their own username and password. We could build a template in the same manner. Now we have the ability to define wifi networks that use user-specific authentication or networks that use a shared password. Either way we can make sure that when those networks are written to the config of the WLC we know they are configured in a consistent manner. On a given WLC there may be 100s of these configs and they may have been deployed at different times by different people. Consistency gives confidence that nothing has been forgotten and that our network administrators have a higher level of familiarity with the configurations on the device. This makes the overall config easier to understand and aids the administrators learn how the overall pieces fit together for a more complete understanding of the system. Working Example Move into the 'other' directory. cd ~/wlc_config_demo cd other ls -la Files: - data.yml: a YAML formatted file that contains our variable definitions - definition-wlan.j2: A template file written using the Jinja templating format - demo.py: a python script that reads in the data.yml file and then renders the jinja template Variable definitions in the data.yml file: $ cat data.yml wlan_name: wlan-pod1 wlan_id: 20 wlan_ssid: POD1-NeT wlan_password: $%mySuperSeCRetPas44** Running the demo.py script: $ ./demo.py wlan WLAN-POD1 20 Pod1-Net security wpa psk set-key ascii 0 $%mySuperSeCRetPas44** no security wpa akm dot1x security wpa akm psk no shutdown wireless tag policy WLAN-POD1-policy-tag description \"Policy Tag for WLAN-POD1-policy-tag\" wlan WLAN-POD1 policy COMPANY-POL-PROF Feel free to play around with the files to produce different results. Not required for this lab however.","title":"Templating Intro"},{"location":"intro_templating/#the-config","text":"wlan {{ wlan_name|upper }} {{ wlan_id }} {{ wlan_ssid|title }} security wpa psk set-key ascii 0 {{ wlan_password }} no security wpa akm dot1x security wpa akm psk no shutdown wireless tag policy {{ wlan_name|upper }}-policy-tag description \"Policy Tag for {{ wlan_name|upper }}-policy-tag\" wlan {{ wlan_name|upper }} policy COMPANY-POL-PROF","title":"The config"},{"location":"intro_templating/#templates","text":"What you see above is the configuration snippet that will define a wifi network and then attach that definition to a particular wireless policy. You'll notice there are several words surrounded by {{ }}. These are variables that can be defined elsewhere. Effectively what the above is showing is a template for the config. We can fill in those variables with names and IDs that meet our needs. The rest of the config is pretty much the same. We can repeat this 100 times, defining 100 lans, and know that they are all configured correctly; no lines missing, ensure a description is added, configured to meet our exact specifications and needs. Some things to note here. - We want the \"wlan_name\" to always be uppercase, aids in spotting the specific config when looking at 100s of lines - We want the \"wlan_ssid\" to use TitleCase, purely aesthetic choice - The wlan ID should always be an integer. If the data provided is not an integer and error will be raised You'll notice that after some of the variable names inside the template have int or title or upper . These are further definitions that will convert whatever is provided to an integer (int), make the name all upper case (upper), or make the string use Title Case (title). So now not only is our config consistent but the format of our provided variables are consistent as well. When perusing the config it makes non-standard config stand out easier. If needed we can build templates for multiple use cases. In the above example the authentication is just using a pre-shared-key, a password shared with everyone that wants to connect to wifi. Perhaps we wanted another template that defined a wifi network that was more secure where every user had their own username and password. We could build a template in the same manner. Now we have the ability to define wifi networks that use user-specific authentication or networks that use a shared password. Either way we can make sure that when those networks are written to the config of the WLC we know they are configured in a consistent manner. On a given WLC there may be 100s of these configs and they may have been deployed at different times by different people. Consistency gives confidence that nothing has been forgotten and that our network administrators have a higher level of familiarity with the configurations on the device. This makes the overall config easier to understand and aids the administrators learn how the overall pieces fit together for a more complete understanding of the system.","title":"Templates"},{"location":"intro_templating/#working-example","text":"Move into the 'other' directory. cd ~/wlc_config_demo cd other ls -la Files: - data.yml: a YAML formatted file that contains our variable definitions - definition-wlan.j2: A template file written using the Jinja templating format - demo.py: a python script that reads in the data.yml file and then renders the jinja template Variable definitions in the data.yml file: $ cat data.yml wlan_name: wlan-pod1 wlan_id: 20 wlan_ssid: POD1-NeT wlan_password: $%mySuperSeCRetPas44** Running the demo.py script: $ ./demo.py wlan WLAN-POD1 20 Pod1-Net security wpa psk set-key ascii 0 $%mySuperSeCRetPas44** no security wpa akm dot1x security wpa akm psk no shutdown wireless tag policy WLAN-POD1-policy-tag description \"Policy Tag for WLAN-POD1-policy-tag\" wlan WLAN-POD1 policy COMPANY-POL-PROF Feel free to play around with the files to produce different results. Not required for this lab however.","title":"Working Example"},{"location":"ansible/ansible_config_push/","text":"Ansible Config Push Now that we've built our inventory and proved we can connect to the device with our credentials lets actually do some automation tasks. In this demo we'll take the templates shown previously, fill them with some data, and push the config to our device. Ansible Vars Ansible uses variables (or vars for short) for all kinds of uses including task and playbook selection along with filling in data for templates. These vars can some from many places. A var can be defined in multiple places and this provides a rich ability to override depending on where it is placed. Perhaps you want to set a default value but for certain types of device override that default with something more appropriate. For a full description of the process have a look at Ansible Variable Precedence . Our Template Vars","title":"Config Push"},{"location":"ansible/ansible_config_push/#ansible-config-push","text":"Now that we've built our inventory and proved we can connect to the device with our credentials lets actually do some automation tasks. In this demo we'll take the templates shown previously, fill them with some data, and push the config to our device.","title":"Ansible Config Push"},{"location":"ansible/ansible_config_push/#ansible-vars","text":"Ansible uses variables (or vars for short) for all kinds of uses including task and playbook selection along with filling in data for templates. These vars can some from many places. A var can be defined in multiple places and this provides a rich ability to override depending on where it is placed. Perhaps you want to set a default value but for certain types of device override that default with something more appropriate. For a full description of the process have a look at Ansible Variable Precedence .","title":"Ansible Vars"},{"location":"ansible/ansible_config_push/#our-template-vars","text":"","title":"Our Template Vars"},{"location":"ansible/ansible_inventory/","text":"Inventory Firstly we need to define our target host, the host where we'll be pushing our config. Make sure you are in the wlc_config_demo directory: cd ~/wlc_config_demo Ansible uses an inventory file to define hosts, groups, and different attributes. You can have multiple inventory files. The file can be manually filled or be generated and filled on-demand by querying some other service like azure or ServiceNow. Since we only have a single host, a simple setup, we'll edit the file manually. nano inventory.yml The contents should look like the following: wlc: hosts: somehost.example.com: ansible_network_os: cisco.ios.ios ansible_connection: ansible.netcommon.network_cli Replace somehost.example.com with n-z2wicon6.stjude.org . This is the name of our wirless lan controller. When connecting to the host, your 'admin' account must be used. Each person should have their own admin account setup. If you are using pod1 as your normal account, then the admin account is pod1admin . Add that so the full config looks like: wlc: hosts: n-z2wicon6.stjude.org: ansible_network_os: cisco.ios.ios ansible_connection: ansible.netcommon.network_cli ansible_user: pod1admin Now hit Ctrl-x to save and exit the editor. Hit y to confirm you want to save. Note that since this is a YAML file, spacing IS important, so be sure the number of leading spaces for each line is correct. In the examples, we'll be using the standard of 2 spaces for each level of hierarchy. Let's perform a couple of simple tests to make sure everything will work as expected. Ansible Ping First we'll 'ping' the host to make sure our machine can at least reach our WLC. Run the command ansible -m ping all (venv) chip@sazcisauto1:~/wlc_config_demo$ ansible -m ping all n-z2wicon6.stjude.org | SUCCESS => { \"changed\": false, \"ping\": \"pong\" } If your output looks like the above then Congratulations! you've run your first ansible command and proved we can reach the host at least. Ansible Get Facts Now let's run another command that will actually log into the device and grab some of the devices attributes. Several of ansible's functions will rely on data collected from the device to decide what tasks or plays to run. For example, the host could be running Ubuntu 22 or it could be running RHEL 9; it could use an ARM CPU or x64. We already know this is a Cisco device running IOS we'll indicate to ansible to collect some basic information about this device. ansible -m ios_facts wlc -k This command will prompt your for an SSH password . Enter the 'admin' password for your user and hit enter to continue. The output should look something like the below: (venv) chip@sazcisauto1:~/wlc_config_demo$ ansible -m ios_facts wlc -k SSH password: n-z2wicon6.stjude.org | SUCCESS => { \"ansible_facts\": { \"ansible_net_api\": \"cliconf\", \"ansible_net_gather_network_resources\": [], \"ansible_net_gather_subset\": [ \"default\" ], \"ansible_net_hostname\": \"n-z2wicon6\", \"ansible_net_image\": \"bootflash:packages.conf\", \"ansible_net_iostype\": \"IOS-XE\", \"ansible_net_model\": \"C9800-L-C-K9\", \"ansible_net_operatingmode\": \"autonomous\", \"ansible_net_python_version\": \"3.10.12\", \"ansible_net_serialnum\": \"REDACTED\", \"ansible_net_system\": \"ios\", \"ansible_net_version\": \"17.09.05\", \"ansible_network_resources\": {} }, \"changed\": false } If your output looks like the above then, again, Congratulations! you have now succesfully logged into the device and had ansible run some commands to gather \"facts\" about the device and return the information to you. Looking at the output we can see that this is, indeed, a device running \"IOS-XE\", version \"17.09.05\", and is a model number \"C9800-L-C-K9\". Let's continue our automation journey by using our templates to push some configuration:","title":"Inventory"},{"location":"ansible/ansible_inventory/#inventory","text":"Firstly we need to define our target host, the host where we'll be pushing our config. Make sure you are in the wlc_config_demo directory: cd ~/wlc_config_demo Ansible uses an inventory file to define hosts, groups, and different attributes. You can have multiple inventory files. The file can be manually filled or be generated and filled on-demand by querying some other service like azure or ServiceNow. Since we only have a single host, a simple setup, we'll edit the file manually. nano inventory.yml The contents should look like the following: wlc: hosts: somehost.example.com: ansible_network_os: cisco.ios.ios ansible_connection: ansible.netcommon.network_cli Replace somehost.example.com with n-z2wicon6.stjude.org . This is the name of our wirless lan controller. When connecting to the host, your 'admin' account must be used. Each person should have their own admin account setup. If you are using pod1 as your normal account, then the admin account is pod1admin . Add that so the full config looks like: wlc: hosts: n-z2wicon6.stjude.org: ansible_network_os: cisco.ios.ios ansible_connection: ansible.netcommon.network_cli ansible_user: pod1admin Now hit Ctrl-x to save and exit the editor. Hit y to confirm you want to save. Note that since this is a YAML file, spacing IS important, so be sure the number of leading spaces for each line is correct. In the examples, we'll be using the standard of 2 spaces for each level of hierarchy. Let's perform a couple of simple tests to make sure everything will work as expected.","title":"Inventory"},{"location":"ansible/ansible_inventory/#ansible-ping","text":"First we'll 'ping' the host to make sure our machine can at least reach our WLC. Run the command ansible -m ping all (venv) chip@sazcisauto1:~/wlc_config_demo$ ansible -m ping all n-z2wicon6.stjude.org | SUCCESS => { \"changed\": false, \"ping\": \"pong\" } If your output looks like the above then Congratulations! you've run your first ansible command and proved we can reach the host at least.","title":"Ansible Ping"},{"location":"ansible/ansible_inventory/#ansible-get-facts","text":"Now let's run another command that will actually log into the device and grab some of the devices attributes. Several of ansible's functions will rely on data collected from the device to decide what tasks or plays to run. For example, the host could be running Ubuntu 22 or it could be running RHEL 9; it could use an ARM CPU or x64. We already know this is a Cisco device running IOS we'll indicate to ansible to collect some basic information about this device. ansible -m ios_facts wlc -k This command will prompt your for an SSH password . Enter the 'admin' password for your user and hit enter to continue. The output should look something like the below: (venv) chip@sazcisauto1:~/wlc_config_demo$ ansible -m ios_facts wlc -k SSH password: n-z2wicon6.stjude.org | SUCCESS => { \"ansible_facts\": { \"ansible_net_api\": \"cliconf\", \"ansible_net_gather_network_resources\": [], \"ansible_net_gather_subset\": [ \"default\" ], \"ansible_net_hostname\": \"n-z2wicon6\", \"ansible_net_image\": \"bootflash:packages.conf\", \"ansible_net_iostype\": \"IOS-XE\", \"ansible_net_model\": \"C9800-L-C-K9\", \"ansible_net_operatingmode\": \"autonomous\", \"ansible_net_python_version\": \"3.10.12\", \"ansible_net_serialnum\": \"REDACTED\", \"ansible_net_system\": \"ios\", \"ansible_net_version\": \"17.09.05\", \"ansible_network_resources\": {} }, \"changed\": false } If your output looks like the above then, again, Congratulations! you have now succesfully logged into the device and had ansible run some commands to gather \"facts\" about the device and return the information to you. Looking at the output we can see that this is, indeed, a device running \"IOS-XE\", version \"17.09.05\", and is a model number \"C9800-L-C-K9\". Let's continue our automation journey by using our templates to push some configuration:","title":"Ansible Get Facts"}]}